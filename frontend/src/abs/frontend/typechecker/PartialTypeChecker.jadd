/* $Id$ */
import abs.common.*;

import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.*;

import abs.frontend.typechecker.TypeCheckerHelper;

import java.util.HashMap;
import abs.frontend.delta.traittype.dependency.*;

aspect PartialTypeChecker {

    public void Block.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        for (Stmt s : getStmts()) {
            s.partialTypeCheck(e,deps);
        }
    }
    public void MethodImpl.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        Block b = getBlock();
        MethodSig sig = getMethodSig();
        b.partialTypeCheck(e,deps);

        if (sig.getName().equals("run")) {
            TypeCheckerHelper.typeCheckRunMethodSig(e, sig);
        }

        Type lastType = getModel().getUnitType();
        ASTNode<?> errorNode = this;
        if (b.getNumStmt() > 0) {
            Stmt lastStmt = b.getStmt(b.getNumStmt()-1);
            lastType = lastStmt.getType();

            // otherwise check is already done in ReturnStmt
            if (lastStmt instanceof ReturnStmt)
                return;
            errorNode = lastStmt;
        }

        if (!lastType.isAssignableTo(sig.getReturnType().getType())) {
            e.add(new TypeError(errorNode,ErrorMessage.CANNOT_ASSIGN,lastType,sig.getReturnType().getType()));
        }

    }

    public void VarDecl.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        int nerrors = e.getErrorCount();
        getAccess().partialTypeCheck(e,deps);
    //    if (e.getErrorCount() > nerrors) return;

        Type t = getAccess().getType();
        if (hasInitExp()) {
            getInitExp().partialTypeCheck(e,deps);
            TypeCheckerHelper.checkInitAssignment(e,this,t,getInitExp(),deps);
        } else {
            if (!t.isReferenceType() && !t.isFutureType()) {
                e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
            }
        }
    }

    public void FieldDecl.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        int nerrors = e.getErrorCount();
        getAccess().partialTypeCheck(e,deps);
        if (e.getErrorCount() > nerrors) return;

        Type t = getAccess().getType();
        if (hasInitExp()) {
            getInitExp().partialTypeCheck(e,deps);
            if (e.getErrorCount() > nerrors) return;
            TypeCheckerHelper.checkInitAssignment(e,this,t,getInitExp(),deps);
        } else {
            if (!t.isReferenceType() && !t.isFutureType()) {
                e.add(new TypeError(this, ErrorMessage.FIELD_INIT_REQUIRED, new String[0]));
            }
        }
    }

    public void ParamDecl.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getAccess().partialTypeCheck(e,deps);
    }



    // STMTS

    public void Stmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
    }

    public void IncompleteStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        // ignore
    }
    public void ExpressionStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getExp().partialTypeCheck(e,deps);
    }

    public void VarDeclStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getVarDecl().partialTypeCheck(e,deps);
        TypeCheckerHelper.checkForDuplicatesOfVarDecl(e, this);
    }
    public void AssignStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        Type rht = null;
        try {
            rht = getValue().getType();
        } catch (Exception e2) {
        }
        Type lht = null;
        try {
            lht = getVar().getType();
        } catch (Exception e2) {         
        }

        int nerrors = e.getErrorCount();
        getValue().partialTypeCheck(e,deps);
        getVar().partialTypeCheck(e,deps);

        TypeCheckerHelper.partiallyCheckAssignment(e,this,getVar(),lht,getValue(),rht,deps);
    }
    public void MoveCogToStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        int nerrors = e.getErrorCount();
        getTarget().partialTypeCheck(e,deps);
        if (e.getErrorCount() > nerrors) return;
        Type t = getTarget().getType();
        Decl d = t.getDecl();
        if (d == null) {
          e.add(new TypeError(this, ErrorMessage.EXPECTED_DC, t));
          return;
        }
        if (!"DeploymentComponent".equals(d.getName())) {
            e.add(new TypeError(this, ErrorMessage.EXPECTED_DC, t));
        }
    }

    public void ReturnStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        MethodImpl m = getContextMethod();
        Type lht = getModel().getUnitType();
        Block block = getContextBlock();

        if (m != null) {
            lht = m.getMethodSig().getReturnType().getType();
            block = m.getBlock();
        }

        Type rht = getRetExp().getType();
        if (!rht.isAssignableTo(lht)) {
            e.add(new TypeError(this,ErrorMessage.CANNOT_ASSIGN,rht,lht));
        }

        getRetExp().partialTypeCheck(e,deps);

        Stmt lastStmt = block.getStmt(block.getNumStmt()-1);
        if (lastStmt != this) {
            e.add(new TypeError(this, ErrorMessage.RETURN_STMT_MUST_BE_LAST, new String[0]));
        }
    }

    public void AwaitStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getGuard().partialTypeCheck(e,deps);
    }

    public void SuspendStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
    }

    public void DurationStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getMin().partialTypeCheck(e,deps);
        getMax().partialTypeCheck(e,deps);
        getMin().assertHasType(e, getModel().getRatType());
        getMax().assertHasType(e, getModel().getRatType());
    }

    public void IfStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getCondition().partialTypeCheck(e,deps);
        getCondition().assertHasType(e,getModel().getBoolType());
        getThen().partialTypeCheck(e,deps);
        if (hasElse())
            getElse().partialTypeCheck(e,deps);

    }

    public void WhileStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getCondition().partialTypeCheck(e,deps);
        getCondition().assertHasType(e,getModel().getBoolType());
        getBody().partialTypeCheck(e,deps);
    }

    public void ForeachStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        
        getListExp().partialTypeCheck(e,deps);
        // assertHasType() is too specific -- we need to check that ListExp is
        // a list, not its specific type (List<Int>)
        if (!getListExp().getType().isUnknownType()
            && !getListExp().getType().getDecl().qualifiedName()
                .equals(getModel().getListType().getDecl().qualifiedName())) {
            e.add(new TypeError(getListExp(), ErrorMessage.EXPECTED_TYPE,
                                getModel().getListType().getDecl().qualifiedName(),
                                getListExp().getType().getDecl().qualifiedName()));
        }
        getBody().partialTypeCheck(e,deps);
    }

    public void CaseStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getExpr().partialTypeCheck(e,deps);
        Type et = getExpr().getType();
        if (!et.isDataType()) {
           e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
           return;
        }
        Type t = getType();
        for (CaseBranchStmt b : getBranchs()) {
          b.partialTypeCheck(e,(DataTypeType) et,new DependencyList());
        }
    }

    public void CaseBranchStmt.partialTypeCheck(SemanticConditionList e, DataTypeType t, DependencyList deps) {
        getLeft().partialTypeCheck(e,t,deps);
        getRight().partialTypeCheck(e,deps);
    }

    public void TryCatchFinallyStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        Type exc = getModel().getExceptionType();
        getBody().partialTypeCheck(e,deps);
        for (CaseBranchStmt b : getCatchs()) {
            b.getLeft().partialTypeCheck(e, exc, deps);
            b.getRight().partialTypeCheck(e,deps);
            for (PatternVarUse pv : b.getLeft().getBoundPatternVars()) {
                e.add(new TypeError(pv, ErrorMessage.MATCHING_NOT_ALLOWED_IN_CATCH, pv.getName()));
            }
        }
        if (hasFinally()) {
            getFinally().partialTypeCheck(e,deps);
            getFinally().checkLegalInit(e, ErrorMessage.NOT_ALLOWED_IN_FINALLY_CODE);
        }
    }

    public void SkipStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
    }

    public void AssertStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getCondition().partialTypeCheck(e,deps);
        getCondition().assertHasType(e,getModel().getBoolType());
    }

    // GUARDS
    public abstract void Guard.partialTypeCheck(SemanticConditionList e, DependencyList deps);
    public void AndGuard.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getLeft().partialTypeCheck(e,deps);
        getRight().partialTypeCheck(e,deps);
    }

    public void ClaimGuard.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getVar().partialTypeCheck(e,deps);
        Type t = getVar().getType();
        if (!t.isFutureType() && !t.isUnknownType()) {
            e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
        }
        if (t.isUnknownType()) {
	        deps.add(new SubTypeDep(new TypeOfLocation(getVar().toString()), TypeOfDependency.FUTURE));
	    }
    }
    public void ExpGuard.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        PureExp exp = getPureExp();
        // We'll only run "deeper" checks if the types check out.
        int size = e.getErrorCount();
        exp.partialTypeCheck(e,deps);
        getPureExp().assertHasType(e,getModel().getBoolType());
        if (e.getErrorCount() == size)
            hasFieldAccess(e); // check for visible change/builtin
    }
    public void DurationGuard.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getMin().partialTypeCheck(e,deps);
        getMax().partialTypeCheck(e,deps);
        getMin().assertHasType(e, getModel().getRatType());
        getMax().assertHasType(e, getModel().getRatType());
    }

    // EXPRESSIONS

    public void Exp.partialTypeCheck(SemanticConditionList e, DependencyList deps) { }

    public void ThisExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
      if (getContextDecl().isUnknown())
        e.add(new TypeError(this,ErrorMessage.THIS_STATIC,""));
    }

    public void OriginalCall.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        /* We are never typeChecking method bodies within deltas at the moment. #386*/
        e.add(new TypeError(this,ErrorMessage.ORIGINAL_NOT_IN_DELTA,""));
    }

    public void TypeUse.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getDecl().checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName());
    }

    public void DataTypeUse.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        if (! getDecl().checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName())) {
            return;
        }
        TypeCheckerHelper.checkDataTypeUse(e, this);
    }

    public void UnresolvedTypeUse.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
    }

    public void VarUse.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        if(getDecl() == null) {
        	deps.add(new FieldDep(this.toString()));
       	}
        TypeCheckerHelper.checkDefBeforeUse(e, this);
    }
    
    public void FieldUse.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
      deps.add(new FieldDep(this.toString()));
      boolean typed = true;
      try{
         TypeCheckerHelper.checkDefBeforeUse(e, this);
      }catch(Exception exc){
     	 typed =false;
      }
      if(typed && !getType().isUnknownType()) {
          deps.add(new SubTypeDep(new TypeOfLocation(this.toString()), new TypeIdentity(getType())));
      }
    }

  public void Call.partialTypeCheckEqualParams(SemanticConditionList e, String method, List<PureExp> list, DependencyList deps) {
      for(int i = 0; i < list.numChildren(); i++){
          PureExp exp = list.getChild(i);
          exp.partialTypeCheck(e,deps);
          Type t = exp.getType();
          if(!t.isUnknownType()){
              deps.add(new SubTypeDep(new TypeOfMethodParameter(method, i), new TypeIdentity(t)));
          } else {
              deps.add(new SubTypeDep(new TypeOfMethodParameter(method, i), new TypeOfLocation(exp.toString())));
             // System.out.println("dep: "+method+"["+i+"]"+" must have the type of "+exp); //TODO 
          }
      }
  }

    public void Call.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
         if (getCallee().getType().isNullType()) {
            e.add(new TypeError(this, ErrorMessage.NULL_NOT_HERE, ""));
            return;
        }

        getCallee().partialTypeCheck(e,deps);
        Type tt = getCallee().getType();
        
        //for variables, get declaration and introduce dependencies from the lhs    
        if(getCallee() instanceof VarUse){
            VarUse vv = (VarUse)getCallee();
            VarOrFieldDecl decl = vv.getDecl();//is null if this is actually a field without this. prefix
            if(decl != null){
                MethodDep mDep = new MethodDep(getMethod(), getNumParam());
                deps.add(mDep);
                deps.add(new HasMethodDep(mDep, decl.getChild(0).toString(), true));
            } else {
        	deps.add(new FieldDep(vv.toString()));
                MethodDep mDep = new MethodDep(getMethod(), getNumParam());
                deps.add(mDep);
                deps.add(new HasMethodDep(mDep, vv.toString(), false));            
            }
            
        //if field type is unknown, put dependency on the field name
        } else if (getCallee().getType() != null && !getCallee().getType().isUnknownType()&& !getCallee().getType().isUnionType()){
            MethodDep mDep = new MethodDep(getMethod(), getNumParam());
            deps.add(mDep);
            deps.add(new HasMethodDep(mDep, tt.toString(), true));
          
            
        //self call
        } else if(getCallee().getType().isUnionType()){
            MethodDep mDep = new MethodDep(getMethod(), getNumParam());
            deps.add(mDep);
            String name = "This";
            if(getContextMethod().getContextDecl() instanceof ClassDecl) name = ((ClassDecl)getContextMethod().getContextDecl()).getName();
            deps.add(new HasMethodDep(mDep, name, true));

        //fieldname known
        } else {
            MethodDep mDep = new MethodDep(getMethod(), getNumParam());
            deps.add(mDep);
            deps.add(new HasMethodDep(mDep, getCallee().toString(), false));
            deps.add(new MethodDep(getMethod(), getNumParam()));
        }
            
        Type t = getType();
        if (t.isUnknownType() || getMethodSig() == null) {
    //        e.add(new TypeError(this, ErrorMessage.NO_METHOD_DECL, getMethod()));
            partialTypeCheckEqualParams(e,getMethod(),getParams(),deps);
        } else {
            typeCheckEqualParams(e,getMethodSig());
        }
    }

    public void NewExp.partialTypeCheck(SemanticConditionList e, DependencyList deps)  {
      deps.add(new ClassDep(getClassName()));
      ASTNode<?> parent = getParent();
      if(parent instanceof AssignStmt){
          AssignStmt assign = (AssignStmt)parent;
          VarOrFieldUse use = assign.getVar();
          if(use.getDecl() == null){
              deps.add(new SubTypeDep(new TypeOfLocation(use.toString()), new TypeIdentity(getClassName())));
          } else {
              deps.add(new SubTypeDep(new TypeIdentity(use.getDecl().getChild(0).toString()), new TypeIdentity(getClassName())));
          }
      }
      parent = parent.getParent();
      if(parent instanceof VarDecl){
          VarDecl decl = (VarDecl)parent;
          deps.add(new SubTypeDep(new TypeIdentity(decl.getChild(0).toString()), new TypeIdentity(getClassName())));
      }
      Decl decl = lookup(new KindedName(Kind.CLASS,getClassName()));
      if (!decl.isClass()) {
          e.add(new TypeError(this, ErrorMessage.NO_CLASS_DECL, getClassName()));
      } else {
          ClassDecl cd = (ClassDecl) decl;
          typeCheckEqualParams(e,cd);
      }
    }
    


    public void GetExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
	    getPureExp().partialTypeCheck(e,deps);
	    if (!getPureExp().getType().isFutureType() && !getPureExp().getType().isUnknownType() ) {
	        e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType()));
	    }
	    if (!getPureExp().getType().isFutureType() && getPureExp().getType().isUnknownType() ) {
	        deps.add(new SubTypeDep(new TypeOfLocation(getPureExp().toString()), TypeOfDependency.FUTURE));
	    }
	}

    public void AddAddExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        // Special case: can also "add" strings.
        Type rt = null;
        try {
            rt = getRight().getType();
        } catch (Exception e2) {
        }
        Type lt = null;
        try {
            lt = getLeft().getType();
        } catch (Exception e2) {        
        }
        if(rt != null && lt != null && !lt.isUnknownType() && !rt.isUnknownType()){
            if (! (lt.isNumericType() || lt.isStringType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, lt));
            }
            if (! (rt.isNumericType() || rt.isStringType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, rt));
            }
            if (!lt.isAssignableTo(rt) && !rt.isAssignableTo(lt)) {
                e.add(new TypeError(this, ErrorMessage.ADD_INCOMPARABLE_TYPE, lt, rt));
            }
        }

        if((rt == null || rt.isUnknownType()) && !lt.isUnknownType() && lt.isNumericType() && getRight() instanceof VarOrFieldUse){
            deps.add(new SubTypeDep(new TypeOfLocation(getRight().toString()), TypeOfDependency.NUMERICAL));
        }
        if((rt == null || rt.isUnknownType()) && !lt.isUnknownType()&& lt.isStringType() && getRight() instanceof VarOrFieldUse){
            deps.add(new SubTypeDep(new TypeOfLocation(getRight().toString()), TypeOfDependency.STRING));
        }
        if((lt == null || lt.isUnknownType()) && !rt.isUnknownType() && rt.isNumericType() && getLeft() instanceof VarOrFieldUse){
            deps.add(new SubTypeDep(new TypeOfLocation(getLeft().toString()), TypeOfDependency.NUMERICAL));
        }
        if((lt == null || lt.isUnknownType()) && !rt.isUnknownType() && rt.isStringType() && getLeft() instanceof VarOrFieldUse){
            deps.add(new SubTypeDep(new TypeOfLocation(getLeft().toString()), TypeOfDependency.STRING));
        }


        getLeft().partialTypeCheck(e,deps);
        getRight().partialTypeCheck(e,deps);
    }
    public void ArithmeticExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        TypeCheckerHelper.partialTypeCheckBinary(e,this,getModel().getRatType(),deps);
    }
    public void BoolExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        TypeCheckerHelper.partialTypeCheckBinary(e,this,getModel().getBoolType(),deps);
    }

    public void RelationalExpr.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getLeft().partialTypeCheck(e,deps);
        getRight().partialTypeCheck(e,deps);
        Type tl = getLeft().getType();
        Type tr = getRight().getType();
        if (!tl.isAssignableTo(tr) && !tr.isAssignableTo(tl)) {
            e.add(new TypeError(this, ErrorMessage.COMPARISON_INCOMPARABLE_TYPE, tl, tr));
        }
    }

    public void IfExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getCondExp().partialTypeCheck(e,deps);
        getCondExp().assertHasType(e,getModel().getBoolType());
        getThenExp().partialTypeCheck(e,deps);
        getElseExp().partialTypeCheck(e,deps);
        Type tt = getThenExp().getType();
        Type et = getElseExp().getType();
        if (!(et.isAssignableTo(tt) || tt.isAssignableTo(et))) {
            e.add(new TypeError(this, ErrorMessage.IF_DIFFERENT_TYPE, tt, et));
        }
    }

    public void CaseExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getExpr().partialTypeCheck(e,deps);
        Type et = getExpr().getType();
        if (!et.isDataType()) {
            e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
            return;
        }
        Type t = getType();
        for (CaseBranch b : getBranchs()) {
            b.partialTypeCheck(e,(DataTypeType) et, deps);
            Type t2 = b.getType();
            if (!t2.isAssignableTo(t)) {
                e.add(new TypeError(this,ErrorMessage.BRANCH_INCOMPARABLE_TYPE,t,t2));
            }
        }
    }

    public void CaseBranch.partialTypeCheck(SemanticConditionList e, DataTypeType t, DependencyList deps) {
        int size = e.getErrorCount();
        getLeft().partialTypeCheck(e,t, deps);
        /* If the LHS is botched, we can't reliably use any variables bound therein. */
        if (e.getErrorCount() == size)
          getRight().partialTypeCheck(e,new DependencyList());
    }

    public void FnApp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        Decl d = getDecl();
        if (!d.isFunction()) {
            e.add(new TypeError(this,ErrorMessage.FUNCTION_NOT_RESOLVABLE,getName()));
        } else {
            ((FunctionDecl)d).typeCheckParams(e, this);
        }
    }

    public void DataConstructorExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        Decl decl = getDecl();
        if (!(decl instanceof DataConstructor)) {
            e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
        } else {
            DataConstructor c = (DataConstructor) decl;
            String cname = c.qualifiedName();
            // Warn about using constructors that should not have been
            // exported from their module
            if (TypeCheckerHelper.deprecatedConstructors.contains(cname)
                && !(cname.startsWith(getModuleDecl().getName()))) {
                e.add(new SemanticWarning(this, ErrorMessage.DEPRECATED_CONSTRUCTOR, c.qualifiedName()));
            }

            if (c.getDataTypeDecl() instanceof ParametricDataTypeDecl) {
                TypeCheckerHelper.typeCheckMatchingParams(e,this,c);
            } else {
                TypeCheckerHelper.typeCheckEqual(e,this,c.getTypes());
            }
        }

    }
    public void LetExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        getVar().partialTypeCheck(e,deps);
        getVal().partialTypeCheck(e,deps);
        getExp().partialTypeCheck(e,deps);
        TypeCheckerHelper.checkInitAssignment(e,this,getVar().getAccess().getType(),getVal(), deps);
    }

    public void MinusExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
         int size = e.getErrorCount();
         getOperand().partialTypeCheck(e,deps);
         if (e.getErrorCount() == size)
             // KLUDGE: we'd like to say "any numeric type please" here
             getOperand().assertHasType(e,getModel().getRatType());
    }

    public void NegExp.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
         int size = e.getErrorCount();
         getOperand().partialTypeCheck(e,deps);
         if (e.getErrorCount() == size)
             getOperand().assertHasType(e,getModel().getBoolType());
    }

    public void ListLiteral.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        Type t = UnknownType.INSTANCE;
        for (PureExp exp : getPureExps()) {
            exp.partialTypeCheck(e,deps);
            Type expt = exp.getType();
            if (!t.isUnknownType()) {
                if (!expt.isAssignableTo(t) && !t.isAssignableTo(expt)) {
                    e.add(new TypeError(exp, ErrorMessage.LIST_LITERAL_TYPE_MISMATCH, t, expt));
                    break;
                }
                if (t.isAssignableTo(expt)) {
                    t = expt;
                }
            } else {
                t = expt;
            }
        }
    }

    // PATTERNS

    public void Pattern.partialTypeCheck(SemanticConditionList e, Type t, DependencyList deps) {  }

    public void PatternVarUse.partialTypeCheck(SemanticConditionList e, Type t, DependencyList deps) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }

    public void LiteralPattern.partialTypeCheck(SemanticConditionList e, Type t, DependencyList deps) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }

    public void ConstructorPattern.partialTypeCheck(SemanticConditionList e, Type t, DependencyList deps) {
        TypeCheckerHelper.typeCheck(this,e,t);
    }

    //ASPECT
    public void ThrowStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getReason().partialTypeCheck(e,deps);
        getReason().assertHasType(e,getModel().getExceptionType());
    }

    public void DieStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {
        super.partialTypeCheck(e,deps);
        getReason().partialTypeCheck(e,deps);
        getReason().assertHasType(e,getModel().getExceptionType());
    }


}


/* Components */
aspect TypeCheckComponents {
    public void MoveStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {}
    public void RebindStmt.partialTypeCheck(SemanticConditionList e, DependencyList deps) {}

    public void ObjectGuard.partialTypeCheck(SemanticConditionList e, DependencyList deps) { }

}
