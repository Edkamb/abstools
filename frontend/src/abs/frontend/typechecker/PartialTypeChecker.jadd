/* $Id$ */
import abs.common.*;

import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.*;

import abs.frontend.typechecker.TypeCheckerHelper;

import java.util.HashMap;

aspect PartialTypeChecker {

    public void Block.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        for (Stmt s : getStmts()) {
            s.partialTypeCheck(e);
        }
    }
    public void MethodImpl.partialTypeCheck(SemanticConditionList e) {
        Block b = getBlock();
        MethodSig sig = getMethodSig();
        b.partialTypeCheck(e);

        if (sig.getName().equals("run")) {
            TypeCheckerHelper.typeCheckRunMethodSig(e, sig);
        }

        Type lastType = getModel().getUnitType();
        ASTNode<?> errorNode = this;
        if (b.getNumStmt() > 0) {
            Stmt lastStmt = b.getStmt(b.getNumStmt()-1);
            lastType = lastStmt.getType();

            // otherwise check is already done in ReturnStmt
            if (lastStmt instanceof ReturnStmt)
                return;
            errorNode = lastStmt;
        }

        if (!lastType.isAssignableTo(sig.getReturnType().getType())) {
            e.add(new TypeError(errorNode,ErrorMessage.CANNOT_ASSIGN,lastType,sig.getReturnType().getType()));
        }

    }

    public void VarDecl.partialTypeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getAccess().partialTypeCheck(e);
    //    if (e.getErrorCount() > nerrors) return;

        Type t = getAccess().getType();
        if (hasInitExp()) {
            getInitExp().partialTypeCheck(e);
            if (e.getErrorCount() > nerrors) return;
            TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
        } else {
            if (!t.isReferenceType() && !t.isFutureType()) {
                e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
            }
        }
    }

    public void FieldDecl.partialTypeCheck(SemanticConditionList e) {
        int nerrors = e.getErrorCount();
        getAccess().partialTypeCheck(e);
        if (e.getErrorCount() > nerrors) return;

        Type t = getAccess().getType();
        if (hasInitExp()) {
            getInitExp().partialTypeCheck(e);
            if (e.getErrorCount() > nerrors) return;
            TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
        } else {
            if (!t.isReferenceType() && !t.isFutureType()) {
                e.add(new TypeError(this, ErrorMessage.FIELD_INIT_REQUIRED, new String[0]));
            }
        }
    }

    public void ParamDecl.partialTypeCheck(SemanticConditionList e) {
        getAccess().partialTypeCheck(e);
    }



    // STMTS

    public void Stmt.partialTypeCheck(SemanticConditionList e) {
    }

    public void IncompleteStmt.partialTypeCheck(SemanticConditionList e) {
        // ignore
    }
    public void ExpressionStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getExp().partialTypeCheck(e);
    }

    public void VarDeclStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getVarDecl().partialTypeCheck(e);
        TypeCheckerHelper.checkForDuplicatesOfVarDecl(e, this);
    }
    public void AssignStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        Type rht = null;
        try {
            rht = getValue().getType();
        } catch (Exception e2) {
        }
        Type lht = null;
        try {
            lht = getVar().getType();
        } catch (Exception e2) {         
        }

        int nerrors = e.getErrorCount();
        getValue().partialTypeCheck(e);
        getVar().partialTypeCheck(e);

        if (e.getErrorCount() > nerrors){
            return;
        }
        TypeCheckerHelper.partiallyCheckAssignment(e,this,getVar(),lht,getValue(),rht);
    }
    public void MoveCogToStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        int nerrors = e.getErrorCount();
        getTarget().partialTypeCheck(e);
        if (e.getErrorCount() > nerrors) return;
        Type t = getTarget().getType();
        Decl d = t.getDecl();
        if (d == null) {
          e.add(new TypeError(this, ErrorMessage.EXPECTED_DC, t));
          return;
        }
        if (!"DeploymentComponent".equals(d.getName())) {
            e.add(new TypeError(this, ErrorMessage.EXPECTED_DC, t));
        }
    }

    public void ReturnStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        MethodImpl m = getContextMethod();
        Type lht = getModel().getUnitType();
        Block block = getContextBlock();

        if (m != null) {
            lht = m.getMethodSig().getReturnType().getType();
            block = m.getBlock();
        }

        Type rht = getRetExp().getType();
        if (!rht.isAssignableTo(lht)) {
            e.add(new TypeError(this,ErrorMessage.CANNOT_ASSIGN,rht,lht));
        }

        getRetExp().partialTypeCheck(e);

        Stmt lastStmt = block.getStmt(block.getNumStmt()-1);
        if (lastStmt != this) {
            e.add(new TypeError(this, ErrorMessage.RETURN_STMT_MUST_BE_LAST, new String[0]));
        }
    }

    public void AwaitStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getGuard().partialTypeCheck(e);
    }

    public void SuspendStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
    }

    public void DurationStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getMin().partialTypeCheck(e);
        getMax().partialTypeCheck(e);
        getMin().assertHasType(e, getModel().getRatType());
        getMax().assertHasType(e, getModel().getRatType());
    }

    public void IfStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getCondition().partialTypeCheck(e);
        getCondition().assertHasType(e,getModel().getBoolType());
        getThen().partialTypeCheck(e);
        if (hasElse())
            getElse().partialTypeCheck(e);

    }

    public void WhileStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getCondition().partialTypeCheck(e);
        getCondition().assertHasType(e,getModel().getBoolType());
        getBody().partialTypeCheck(e);
    }

    public void ForeachStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        
        getListExp().partialTypeCheck(e);
        // assertHasType() is too specific -- we need to check that ListExp is
        // a list, not its specific type (List<Int>)
        if (!getListExp().getType().isUnknownType()
            && !getListExp().getType().getDecl().qualifiedName()
                .equals(getModel().getListType().getDecl().qualifiedName())) {
            e.add(new TypeError(getListExp(), ErrorMessage.EXPECTED_TYPE,
                                getModel().getListType().getDecl().qualifiedName(),
                                getListExp().getType().getDecl().qualifiedName()));
        }
        getBody().partialTypeCheck(e);
    }

    public void CaseStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getExpr().partialTypeCheck(e);
        Type et = getExpr().getType();
        if (!et.isDataType()) {
           e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
           return;
        }
        Type t = getType();
        for (CaseBranchStmt b : getBranchs()) {
          b.partialTypeCheck(e,(DataTypeType) et);
        }
    }

    public void CaseBranchStmt.partialTypeCheck(SemanticConditionList e, DataTypeType t) {
        getLeft().partialTypeCheck(e,t);
        getRight().partialTypeCheck(e);
    }

    public void TryCatchFinallyStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        Type exc = getModel().getExceptionType();
        getBody().partialTypeCheck(e);
        for (CaseBranchStmt b : getCatchs()) {
            b.getLeft().partialTypeCheck(e, exc);
            b.getRight().partialTypeCheck(e);
            for (PatternVarUse pv : b.getLeft().getBoundPatternVars()) {
                e.add(new TypeError(pv, ErrorMessage.MATCHING_NOT_ALLOWED_IN_CATCH, pv.getName()));
            }
        }
        if (hasFinally()) {
            getFinally().partialTypeCheck(e);
            getFinally().checkLegalInit(e, ErrorMessage.NOT_ALLOWED_IN_FINALLY_CODE);
        }
    }

    public void SkipStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
    }

    public void AssertStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getCondition().partialTypeCheck(e);
        getCondition().assertHasType(e,getModel().getBoolType());
    }

    // GUARDS
    public abstract void Guard.partialTypeCheck(SemanticConditionList e);
    public void AndGuard.partialTypeCheck(SemanticConditionList e) {
        getLeft().partialTypeCheck(e);
        getRight().partialTypeCheck(e);
    }

    public void ClaimGuard.partialTypeCheck(SemanticConditionList e) {
        getVar().partialTypeCheck(e);
        Type t = getVar().getType();
        if (!t.isFutureType()) {
            e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
        }
    }
    public void ExpGuard.partialTypeCheck(SemanticConditionList e) {
        PureExp exp = getPureExp();
        // We'll only run "deeper" checks if the types check out.
        int size = e.getErrorCount();
        exp.partialTypeCheck(e);
        getPureExp().assertHasType(e,getModel().getBoolType());
        if (e.getErrorCount() == size)
            hasFieldAccess(e); // check for visible change/builtin
    }
    public void DurationGuard.partialTypeCheck(SemanticConditionList e) {
        getMin().partialTypeCheck(e);
        getMax().partialTypeCheck(e);
        getMin().assertHasType(e, getModel().getRatType());
        getMax().assertHasType(e, getModel().getRatType());
    }

    // EXPRESSIONS

    public void Exp.partialTypeCheck(SemanticConditionList e) { }

    public void ThisExp.partialTypeCheck(SemanticConditionList e) {
      if (getContextDecl().isUnknown())
        e.add(new TypeError(this,ErrorMessage.THIS_STATIC,""));
    }

    public void OriginalCall.partialTypeCheck(SemanticConditionList e) {
        /* We are never typeChecking method bodies within deltas at the moment. #386*/
        e.add(new TypeError(this,ErrorMessage.ORIGINAL_NOT_IN_DELTA,""));
    }

    public void TypeUse.partialTypeCheck(SemanticConditionList e) {
        getDecl().checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName());
    }

    public void DataTypeUse.partialTypeCheck(SemanticConditionList e) {
        if (! getDecl().checkDecl(this, e, ErrorMessage.TYPE_NOT_RESOLVABLE, getName())) {
            return;
        }
        TypeCheckerHelper.checkDataTypeUse(e, this);
    }

    public void UnresolvedTypeUse.partialTypeCheck(SemanticConditionList e) {
        e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
    }

    public void VarUse.partialTypeCheck(SemanticConditionList e) {
        if(getDecl() == null) System.out.println("dep: "+this+" must exist");
        TypeCheckerHelper.checkDefBeforeUse(e, this);
    }
    
    public void FieldUse.partialTypeCheck(SemanticConditionList e) {
      System.out.println("dep: "+this+" must exist");
      boolean typed = true;
      try{
         TypeCheckerHelper.checkDefBeforeUse(e, this);
      }catch(Exception exc){
     	 typed =false;
      }
      if(typed && !getType().isUnknownType()) System.out.println("dep: "+this+" be must subtype of "+getType());
    }

    public void Call.partialTypeCheck(SemanticConditionList e) {
        if (getCallee().getType().isNullType()) {
            e.add(new TypeError(this, ErrorMessage.NULL_NOT_HERE, ""));
            return;
        }

        getCallee().partialTypeCheck(e);
        Type tt = getCallee().getType();
        
        //for variables, get declaration and introduce dependencies from the lhs    
        if(getCallee() instanceof VarUse){
            VarUse vv = (VarUse)getCallee();
            VarDecl decl = (VarDecl) vv.getDecl();
            System.out.println("dep: "+ decl.getChild(0)  + " must have method "+getMethod());
            
        //if field type is unknown, put dependency on the field name
        } else if (getCallee().getType() != null && !getCallee().getType().isUnknownType()&& !getCallee().getType().isUnionType()){
            System.out.println("dep: "+ tt  + " must have method "+getMethod());
          
            
        //self call
        } else if(getCallee().getType().isUnionType()){
            System.out.println("dep: self must have method "+getMethod());

        //fieldname known
        } else {
            System.out.println("dep: "+getCallee() + " must have method "+getMethod());
        }
            
        Type t = getType();
        if (t.isUnknownType() || getMethodSig() == null) {
            e.add(new TypeError(this, ErrorMessage.NO_METHOD_DECL, getMethod()));
        } else {
            typeCheckEqualParams(e,getMethodSig());
        }
    }

    public void NewExp.partialTypeCheck(SemanticConditionList e) {
      System.out.println("dep: "+getClassName()+" must exist");
      ASTNode<?> parent = getParent();
      if(parent instanceof AssignStmt){
          AssignStmt assign = (AssignStmt)parent;
          VarOrFieldUse use = assign.getVar();
          if(use.getDecl() == null)
              System.out.println("dep: "+use+" must have a type implemented by "+getClassName());
          else
              System.out.println("dep: "+use.getDecl().getChild(0) +" must be implemented by "+getClassName());
      }
      parent = parent.getParent();
      if(parent instanceof VarDecl){
          VarDecl decl = (VarDecl)parent;
          System.out.println("dep: "+decl.getChild(0) +" must be implemented by "+getClassName());
      }
      Decl decl = lookup(new KindedName(Kind.CLASS,getClassName()));
      if (!decl.isClass()) {
          e.add(new TypeError(this, ErrorMessage.NO_CLASS_DECL, getClassName()));
      } else {
          ClassDecl cd = (ClassDecl) decl;
          typeCheckEqualParams(e,cd);
      }
    }


    public void GetExp.partialTypeCheck(SemanticConditionList e) {
        if (!getPureExp().getType().isFutureType()) {
            e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType()));
        }
        getPureExp().partialTypeCheck(e);
    }
    public void AddAddExp.partialTypeCheck(SemanticConditionList e) {
        // Special case: can also "add" strings.
        Type rt = null;
        try {
            rt = getRight().getType();
        } catch (Exception e2) {
        }
        Type lt = null;
        try {
            lt = getLeft().getType();
        } catch (Exception e2) {        
        }
        if(rt != null && lt != null){
            if (! (lt.isNumericType() || lt.isStringType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, lt));
            }
            if (! (rt.isNumericType() || rt.isStringType())) {
                e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, rt));
            }
            if (!lt.isAssignableTo(rt) && !rt.isAssignableTo(lt)) {
                e.add(new TypeError(this, ErrorMessage.ADD_INCOMPARABLE_TYPE, lt, rt));
            }
        }
        if(rt == null && lt != null && lt.isNumericType()){
            System.out.println("dep: "+getRight()+" must be numeric");
        }
        if(rt == null && lt != null && lt.isStringType()){
            System.out.println("dep: "+getRight()+" must be string");
        }
        if(lt == null && rt != null && rt.isNumericType()){
            System.out.println("dep: "+getLeft()+" must be numeric");
        }
        if(lt == null && rt != null && rt.isStringType()){
            System.out.println("dep: "+getLeft()+" must be string");
        }

        getLeft().partialTypeCheck(e);
        getRight().partialTypeCheck(e);
    }
    public void ArithmeticExp.partialTypeCheck(SemanticConditionList e) {
        TypeCheckerHelper.partialTypeCheckBinary(e,this,getModel().getRatType());
    }
    public void BoolExp.partialTypeCheck(SemanticConditionList e) {
        TypeCheckerHelper.partialTypeCheckBinary(e,this,getModel().getBoolType());
    }

    public void RelationalExpr.partialTypeCheck(SemanticConditionList e) {
        getLeft().partialTypeCheck(e);
        getRight().partialTypeCheck(e);
        Type tl = getLeft().getType();
        Type tr = getRight().getType();
        if (!tl.isAssignableTo(tr) && !tr.isAssignableTo(tl)) {
            e.add(new TypeError(this, ErrorMessage.COMPARISON_INCOMPARABLE_TYPE, tl, tr));
        }
    }

    public void IfExp.partialTypeCheck(SemanticConditionList e) {
        getCondExp().partialTypeCheck(e);
        getCondExp().assertHasType(e,getModel().getBoolType());
        getThenExp().partialTypeCheck(e);
        getElseExp().partialTypeCheck(e);
        Type tt = getThenExp().getType();
        Type et = getElseExp().getType();
        if (!(et.isAssignableTo(tt) || tt.isAssignableTo(et))) {
            e.add(new TypeError(this, ErrorMessage.IF_DIFFERENT_TYPE, tt, et));
        }
    }

    public void CaseExp.partialTypeCheck(SemanticConditionList e) {
        getExpr().partialTypeCheck(e);
        Type et = getExpr().getType();
        if (!et.isDataType()) {
            e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
            return;
        }
        Type t = getType();
        for (CaseBranch b : getBranchs()) {
            b.partialTypeCheck(e,(DataTypeType) et);
            Type t2 = b.getType();
            if (!t2.isAssignableTo(t)) {
                e.add(new TypeError(this,ErrorMessage.BRANCH_INCOMPARABLE_TYPE,t,t2));
            }
        }
    }

    public void CaseBranch.partialTypeCheck(SemanticConditionList e, DataTypeType t) {
        int size = e.getErrorCount();
        getLeft().partialTypeCheck(e,t);
        /* If the LHS is botched, we can't reliably use any variables bound therein. */
        if (e.getErrorCount() == size)
          getRight().partialTypeCheck(e);
    }

    public void FnApp.partialTypeCheck(SemanticConditionList e) {
        Decl d = getDecl();
        if (!d.isFunction()) {
            e.add(new TypeError(this,ErrorMessage.FUNCTION_NOT_RESOLVABLE,getName()));
        } else {
            ((FunctionDecl)d).typeCheckParams(e, this);
        }
    }

    public void DataConstructorExp.partialTypeCheck(SemanticConditionList e) {
        Decl decl = getDecl();
        if (!(decl instanceof DataConstructor)) {
            e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
        } else {
            DataConstructor c = (DataConstructor) decl;
            String cname = c.qualifiedName();
            // Warn about using constructors that should not have been
            // exported from their module
            if (TypeCheckerHelper.deprecatedConstructors.contains(cname)
                && !(cname.startsWith(getModuleDecl().getName()))) {
                e.add(new SemanticWarning(this, ErrorMessage.DEPRECATED_CONSTRUCTOR, c.qualifiedName()));
            }

            if (c.getDataTypeDecl() instanceof ParametricDataTypeDecl) {
                TypeCheckerHelper.typeCheckMatchingParams(e,this,c);
            } else {
                TypeCheckerHelper.typeCheckEqual(e,this,c.getTypes());
            }
        }

    }
    public void LetExp.partialTypeCheck(SemanticConditionList e) {
        getVar().partialTypeCheck(e);
        getVal().partialTypeCheck(e);
        getExp().partialTypeCheck(e);
        TypeCheckerHelper.checkAssignment(e,this,getVar().getAccess().getType(),getVal());
    }

    public void MinusExp.partialTypeCheck(SemanticConditionList e) {
         int size = e.getErrorCount();
         getOperand().partialTypeCheck(e);
         if (e.getErrorCount() == size)
             // KLUDGE: we'd like to say "any numeric type please" here
             getOperand().assertHasType(e,getModel().getRatType());
    }

    public void NegExp.partialTypeCheck(SemanticConditionList e) {
         int size = e.getErrorCount();
         getOperand().partialTypeCheck(e);
         if (e.getErrorCount() == size)
             getOperand().assertHasType(e,getModel().getBoolType());
    }

    public void ListLiteral.partialTypeCheck(SemanticConditionList e) {
        Type t = UnknownType.INSTANCE;
        for (PureExp exp : getPureExps()) {
            exp.partialTypeCheck(e);
            Type expt = exp.getType();
            if (!t.isUnknownType()) {
                if (!expt.isAssignableTo(t) && !t.isAssignableTo(expt)) {
                    e.add(new TypeError(exp, ErrorMessage.LIST_LITERAL_TYPE_MISMATCH, t, expt));
                    break;
                }
                if (t.isAssignableTo(expt)) {
                    t = expt;
                }
            } else {
                t = expt;
            }
        }
    }

    // PATTERNS

    public void Pattern.partialTypeCheck(SemanticConditionList e, Type t) {  }

    public void PatternVarUse.partialTypeCheck(SemanticConditionList e, Type t) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }

    public void LiteralPattern.partialTypeCheck(SemanticConditionList e, Type t) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }

    public void ConstructorPattern.partialTypeCheck(SemanticConditionList e, Type t) {
        TypeCheckerHelper.typeCheck(this,e,t);
    }

    //ASPECT
    public void ThrowStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getReason().partialTypeCheck(e);
        getReason().assertHasType(e,getModel().getExceptionType());
    }

    public void DieStmt.partialTypeCheck(SemanticConditionList e) {
        super.partialTypeCheck(e);
        getReason().partialTypeCheck(e);
        getReason().assertHasType(e,getModel().getExceptionType());
    }


}


/* Components */
aspect TypeCheckComponents {
    public void MoveStmt.partialTypeCheck(SemanticConditionList e) {}
    public void RebindStmt.partialTypeCheck(SemanticConditionList e) {}

    public void ObjectGuard.partialTypeCheck(SemanticConditionList e) { }

}
