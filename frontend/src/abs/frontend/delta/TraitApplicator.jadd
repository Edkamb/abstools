import java.util.Map;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.common.*;
import abs.frontend.parser.*;


aspect TraitApplicator {

  	
    /*
    * DeltaTraitModifier references trait operations from a class.
    */
    public void DeltaTraitModifier.applyTo(ClassDecl cd) throws DeltaModellingException{ 
        getTraitOper().applyTo(cd); 
    }

    /*
     * TraitUse is the trait application from within a class. Transform it into
     * a TraitAddOpr and apply it.
     */
    public  void TraitUse.applyTo(ClassDecl cd) throws DeltaModellingException {

        //find TraitDecl
        List<Decl> list = cd.getModuleDecl().getDecls();
        TraitExpr resolved = getTraitExpr();
        if(getTraitExpr() instanceof TraitNameExpr){
            TraitNameExpr n = (TraitNameExpr) getTraitExpr();
            for (Decl decl : list) {
                if(decl instanceof TraitDecl){
                    TraitDecl tDecl = (TraitDecl)decl;
                    if( tDecl.getName().equals(n.getName()) ){
                        resolved = tDecl.getTraitExpr();
                        break;
                    }
                }
            }
        } 
        
         //transform into TraitAddOpr
        TraitSetExpr eSet = new TraitSetExpr();
        eSet.setMethodImplList(new List<MethodImpl>());
        eSet.setParent(cd);
        
        resolved = resolved.treeCopyNoTransform();
        TraitAddOpr tOp = new TraitAddOpr(resolved);
        tOp.setParent(cd);
        resolved.setParent(tOp);
          
        
        TraitSetExpr newSet = tOp.applyToSet(eSet, cd);
        TraitAddOpr newOp = new TraitAddOpr(newSet);
        newOp.setParent(cd);
        
        //apply
        newOp.applyTo(cd);
          
        //remove from class
        int pos = cd.getTraitUseList().getIndexOfChild(this);
        if(pos > -1){
            cd.getTraitUseList().removeChild(pos);
        }
          
        //cache
        cd.getModuleDecl().flushCache();
    }
    
    

    /*
     * TraitRemoveOpr is the trait operation that removes a single method, given
     * its signature. Throws an exception if no such method is found
     */
    public  void TraitRemoveOpr.applyTo(ClassDecl cd) throws DeltaModellingException{    
        applyToList(cd.getMethodList());
    }
    
    private void TraitRemoveOpr.applyToList(List<MethodImpl> list) throws DeltaModellingException{ 
        MethodSig mysig = this.getMethodSig();

        // in given ClassDecl: find MethodDecl that matches sig
        int found = -1;
        for (int i = 0; i < list.getNumChild(); i++) {
            MethodSig sig = list.getChild(i).getMethodSig();
            if (sig.matches(mysig)) {
                found = i;
                break;
            }
        }
       
        if (found >= 0)
            // remove MethodImpl from list
            list.removeChild(found);
        else
            throw new DeltaModellingException( 
                      "trait wants to remove method [" + mysig + "], which was not found");
    }



    /*
     * TraitAddOpr is the trait operation that adds a set of methods. Throws NO
     * exception if a method with the same name is already present in the class
     */
    public void TraitAddOpr.applyTo(ClassDecl cd) throws DeltaModellingException{ 
        TraitExpr tt = getTraitExpr();
        ArrayList<TraitOper> operations = new ArrayList<>();
        /*
         *  The syntax is TraitExpression TraitOperation. 
         *  We search for the TraitExpression that is used by this 'adds'
         *  This may break the syntax, thus we collect all operation on the right
         *  and apply them one by one.
         */
        TraitExpr target = helperLeftMost(tt, operations);
                      
        
            TraitSetExpr set = tt.resolve(cd);
            for (MethodImpl met : set.getMethodImplList()) {
		          MethodImpl newMet = met.treeCopyNoTransform();
		          newMet.setParent(met.getParent());
		          MethodSig newSig = met.getMethodSig().treeCopyNoTransform();
		          newSig.setParent(newMet);
		          newMet.setMethodSig(newSig);
		          cd.addMethod(newMet);
            }

        //necessary because the helper collects them in the wrong order
        Collections.reverse(operations);
        for (TraitOper oper : operations) {
            oper.applyTo(cd);
        }
    }    

    // collects all TraitOper in an AST and returns the left-most TraitExpr
    public TraitExpr TraitAddOpr.helperLeftMost(TraitExpr tt, ArrayList<TraitOper> operations){
        if(tt instanceof TraitModifyExpr){          
            TraitModifyExpr app = (TraitModifyExpr) tt;
            TraitExpr next = app.getTraitExpr();
            TraitOper opr = app.getTraitOper();
            operations.add(opr);
            return helperLeftMost(next, operations);
        } else return tt;
    }


    /*
     * TraitModifyOpr is the trait operation that modifies a set of methods.
     * Throws an exception if a method with the same name is not present in the
     * class
     *
     * This is also where we resolve original calls.
     */
    public void TraitModifyOpr.applyTo(ClassDecl cd) throws DeltaModellingException{ 
        TraitExpr tt = getTraitExpr();
        ArrayList<TraitOper> operations = new ArrayList<>();
        TraitExpr target = helperLeftMost(tt, operations);

            TraitSetExpr set = target.resolve(cd);
            for (MethodImpl met : set.getMethodImplList()) {
                apply(cd,met);
            }

        for (TraitOper oper : operations) {
            oper.applyTo(cd);
        }
    }

    // collects all TraitOper in an AST and returns the left-most TraitExpr
    public TraitExpr TraitModifyOpr.helperLeftMost(TraitExpr tt, ArrayList<TraitOper> operations){
        if(tt instanceof TraitModifyExpr){          
            TraitModifyExpr app = (TraitModifyExpr) tt;
            TraitExpr next = app.getTraitExpr();
            TraitOper opr = app.getTraitOper();
            operations.add(opr);
            return helperLeftMost(next, operations);
        } else return tt;
    }

    // modifies a single method
    private void TraitModifyOpr.apply(ClassDecl cd, MethodImpl met) throws DeltaModellingException{
        MethodSig mysig = met.getMethodSig();

        // in given ClassDecl: find MethodDecl that matches sig
        int found = -1;
        for (int i = 0; i < cd.getNumMethod(); i++) {
            MethodSig sig = cd.getMethod(i).getMethodSig();
            if (sig.matches(mysig)) {
                found = i;
                break;
            }
        }
        if (found >= 0) {
            // replace MethodImpl
            MethodImpl method = met.treeCopyNoTransform();
            method.setFileName(met.getFileName());
            method.setParent(met.getParent());
            replaceOriginal(cd, cd.getMethod(found), method);
            cd.getMethods().setChild(method, found);
        } else
            throw new DeltaModellingException(met.getMethodSig()+
                    " wants to modify method [" + mysig + "], which was not found in class [" + cd.qualifiedName() + "].");
    }

    /*
     * These two static fields map are needed to resolve targeted original
     * calls. deltas is needed to remember the last applies delta (or 'core')
     * deltaMap maps methodnames to a map that maps delta-names (and 'core') to
     * the method bodies _before_ the application of that delta
     */
    private static Stack<String> TraitModifyOpr.deltas=new Stack<>();
    private static HashMap<String, HashMap<String, MethodImpl>> TraitModifyOpr.deltaMap=new HashMap<>();

    // replaces all original calls
    private void TraitModifyOpr.replaceOriginal(ClassDecl cd, MethodImpl met, MethodImpl flattened) {
                
        //find current delta
        ASTNode<ASTNode> n = this;
        while(n != null && !(n instanceof DeltaDecl)){
            n = n.getParent();
        }
        DeltaDecl delta  = (DeltaDecl)n;
          
        //init it this is the first delta
        if(delta != null){
            String mName = met.getMethodSig().getName();
            HashMap<String, MethodImpl> map = deltaMap.get(mName);
            if(map == null){
                map = new HashMap<>();
                map.put("core", flattened);
                deltas.push("core");
                deltaMap.put(mName, map);
            }
        }
          
        //collect all original calls
        ArrayList<OriginalCall> list = new ArrayList<>();
        for (Stmt stmt : flattened.getBlock().getStmts()){
            collectOrig(list, stmt);
        }
          
          
        if(list.size() > 0){
            //rename
            int i = cd.getNumMethod();
            String name = met.getMethodSig().getName() + (delta == null? hashCode() : "_"+delta.getName());
            MethodSig sig = met.getMethodSig().treeCopyNoTransform();
            sig.setName(name);
              
            //add
            MethodImpl newMet = met.treeCopyNoTransform();
            newMet.setParent(met.getParent());
            newMet.setMethodSig(sig);

            sig.setParent(newMet);
            cd.getMethods().setChild(newMet, i);

            //save delta
            if(delta != null){
                String mName = met.getMethodSig().getName();
                HashMap<String, MethodImpl> map = deltaMap.get(mName);
                map.put(deltas.peek(), newMet);
                map.put(delta.getName(), flattened);
                deltas.push(delta.getName());
            }
              
            //replace
            for (OriginalCall orig : list) {
                orig.replaceByRealCall(newMet, deltaMap.get(met.getMethodSig().getName()));
            }
        }      
    }

    // collect all original calls
    private void TraitModifyOpr.collectOrig(ArrayList<OriginalCall> list, ASTNode<ASTNode> node){
        if(node instanceof OriginalCall){
            list.add((OriginalCall)node);
            return;
        }
        if(node != null && node.children != null){
            for (ASTNode<ASTNode> child : node.children) {
                collectOrig(list,child);
            }
        }
    }
    
}