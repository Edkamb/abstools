import java.util.Map;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.common.*;
import abs.frontend.parser.*;

/*
 * Collection of methods to be added to the various Modifiers inside a delta:
 * - ModuleModifiers, which can be 
 *   OOModifiers, which in turn contain: 
 *     - AddClassModifier, RemoveClassModifier, ModifyClassModifier
 *     - AddInterfaceModifier, ModifyInterfaceModifier
 *   FunctionalModifiers, which in turn contain:
 *     - AddFunctionModifier, AddDataTypeModifier, AddTypeSynModifier
 */
aspect DeltaModifierApplicator {

    abstract public void ModuleModifier.apply() throws DeltaModellingException;

    /**************************************************************************
     * OOModifiers add/remove/modify classes or interfaces
     * they are applied to Modules
     */
    
    public void AddClassModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        ClassDecl cls = getClassDecl().treeCopyNoTransform();
        cls.setFileName(getClassDecl().getFileName());
        cls.setName(getSimpleName());
        module.getDecls().addChild(cls);
    }
    
    public void RemoveClassModifier.apply() throws DeltaModellingException {
        ClassDecl cls = findClass();
        ModuleDecl module = cls.getModuleDecl();
        module.getDecls().removeChild(module.getDecls().getIndexOfChild(cls));
    }

    public void ModifyClassModifier.apply() throws DeltaModellingException {
        ClassDecl cls = findClass();
        if (cls == null)
           throw new DeltaModellingException(getDelta(), 
                " wants to modify class [" + getName() + "], which was not found.");

        
        // add any interfaces added by the ClassModifier
        for (InterfaceTypeUse iface : this.getAddedInterfaces()) {
            InterfaceTypeUse iface2 = iface.treeCopyNoTransform();
            iface2.setFileName(iface.getFileName());
            cls.addImplementedInterfaceUse(iface2);
        }

        // remove any interfaces removed by the ClassModifier
        for (InterfaceTypeUse toRemove : this.getRemovedInterfaces()) {
            boolean found = false;
            for (InterfaceTypeUse iface : cls.getImplementedInterfaceUseList()) {
                if (iface.getName().equals(toRemove.getName())) {
                    cls.getImplementedInterfaceUseList().removeChild(cls.getImplementedInterfaceUseList().getIndexOfChild(iface));
                    found = true;
                    break;
                }
            }
            if (! found)
                throw new DeltaModellingException(getDelta(), 
                    " wants to remove interface [" + toRemove.getName() + "] from class [" + cls.getName() 
                    + "]. However, the class does not implement that interface.");
        }

        // apply all modifiers
        for (Modifier mod : this.getModifiers()) {
            mod.applyTo(cls);
        }
    }
    
    public void AddInterfaceModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        assert module.lookup(new KindedName(Kind.TYPE_DECL, getSimpleName())).isUnknown();
        InterfaceDecl decl = getInterfaceDecl().treeCopyNoTransform();
        decl.setFileName(getInterfaceDecl().getFileName());
        decl.setName(getSimpleName());
        module.getDecls().addChild(decl);
    }
    public void ModifyInterfaceModifier.apply() throws DeltaModellingException {
        InterfaceDecl iface = this.findInterface();
        // apply all modifiers
        for (MethodSigModifier mod : this.getMethodSigModifiers()) {
            mod.applyTo(iface);
        }
    }
    public void RemoveInterfaceModifier.apply() throws DeltaModellingException {
        InterfaceDecl iface = this.findInterface();
        ModuleDecl module = iface.getModuleDecl();
        module.getDecls().removeChild(module.getDecls().getIndexOfChild(iface));
    }
    
    /**************************************************************************
     * FunctionalModifiers add functions, data types and type synonyms
     * they are applied to Modules
     */

    public String AddFunctionModifier.toString() {
        return "adds function " + getFunctionDecl().getName();
    }
    
    public void AddFunctionModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        FunctionDecl func = getFunctionDecl().treeCopyNoTransform();
        func.setFileName(getFunctionDecl().getFileName());
        module.getDecls().addChild(func);
    }
    
    public String AddDataTypeModifier.toString() {
        return "adds data type " + getDataTypeDecl().getName();
    }
    
    public void AddDataTypeModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        
        DataTypeDecl dtd = this.getDataTypeDecl().treeCopyNoTransform();
        dtd.setFileName(getDataTypeDecl().getFileName());
        module.getDecls().addChild(dtd);
        for (DataConstructor c : dtd.getDataConstructors()) {
            int i = 0;
            for (ConstructorArg ca : c.getConstructorArgs()) {
                if (ca.hasSelectorName()) {
                    module.getDecls().addChild(new ASTPreProcessor().createSelectorFunctionForDeltaApplication(dtd, c, ca, i));
                }
                i++;
            }
        }
    }
    
    public String AddTypeSynModifier.toString() {
        return "adds type synonym " + getTypeSynDecl().getName();
    }
    
    public void AddTypeSynModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        TypeSynDecl type = getTypeSynDecl().treeCopyNoTransform();
        type.setFileName(getTypeSynDecl().getFileName());
        module.getDecls().addChild(type);
    }

    public void ModifyTypeSynModifier.apply() throws DeltaModellingException {
        TypeSynDecl syndecl = null;
        ModuleDecl module = findModule();
        for (Decl decl : module.getDecls()) {
            if (decl instanceof TypeSynDecl && decl.getName().equals(this.getSimpleName()))
                syndecl = (TypeSynDecl)decl;
        }
        if (syndecl == null) {
            throw new DeltaModellingException(getDelta(), 
                " wants to modify type synonym [" + this.getSimpleName() + "], which was not found in module [" + module.getName() + "].");
        } else {
            syndecl.setValue((TypeUse) getTypeSynDecl().getValue().treeCopyNoTransform());
        }
    }

    public void ModifyDataTypeModifier.apply() throws DeltaModellingException {
        DataTypeDecl datatypedecl = null;
        ModuleDecl module = findModule();
        for (Decl decl : module.getDecls()) {
            if (decl instanceof DataTypeDecl && decl.getName().equals(this.getSimpleName()))
                datatypedecl = (DataTypeDecl)decl;
        }
        if (datatypedecl == null) {
            throw new DeltaModellingException(getDelta(), 
                " wants to modify datatype [" + this.getSimpleName() + "], which was not found in module [" + module.getName() + "].");
        } else {
            datatypedecl.setDataConstructorList(this.getDataTypeDecl().getDataConstructorList().treeCopyNoTransform());
            if (datatypedecl instanceof ParametricDataTypeDecl
                && this.getDataTypeDecl() instanceof ParametricDataTypeDecl) {
                ((ParametricDataTypeDecl)datatypedecl).setTypeParameterList(((ParametricDataTypeDecl)this.getDataTypeDecl()).getTypeParameterList().treeCopyNoTransform());
            } else {
                throw new DeltaModellingException(getDelta(), 
                    " wants to convert datatype [" + this.getSimpleName() + "] from or to a parametric datatype, which is not supported yet.");
            }
        }
    }

    /**************************************************************************
     * NamespaceModifiers add imports and exports
     * they are applied to Modules
     */
    public void AddImportModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        module.addImport((Import)getImport().treeCopyNoTransform());
        
    }
    public void AddExportModifier.apply() throws DeltaModellingException {
        ModuleDecl module = findModule();
        module.addExport((Export)getExport().treeCopyNoTransform());
    }
    
    /**************************************************************************
     * helper method
     * find the ModuleDecl to which this ModuleModifier applies
     * if qualified => easy; if unqualified => look in delta's 'uses' list.
     */
    public ModuleDecl ModuleModifier.findModule() throws DeltaModellingException {
        String moduleid;
        Name name = new Name(getName());
        if (name.isSimple()) {
            // assume the module name was specified in a 'uses' statement
            // For now we only check the first used module - does having multiple 'uses' statements ever make sense?
            // If not, FIXME change the syntax accordingly.
            try {
                moduleid = getDelta().getDeltaAccess(0).getModuleName();
            } catch(NullPointerException e) {
                throw new DeltaModellingException(getDelta(),"Unqualified name of modified entity requires "
                        + "a \'uses\' statement inside the delta, to determine the module to be modified.");
            }
        } else {
            moduleid = name.getModuleName();
        }            

        for (ModuleDecl module : getModel().getModuleDecls()) {
            if (module.getName().equals(moduleid)) {
                return module;
            }
        }
        throw new DeltaModellingException(getDelta(), 
                " wants to modify module [" + moduleid + "], which was not found.");
    }


    
    /**************************************************************************
     * helper methods
     * find the (Class or Interface) Decl which should be modified by this OOModifier
     */
    public ClassDecl ClassModifier.findClass() {
        //System.out.println("=== Delta " + getDelta().getName() + " looking for ClassDecl: " + this.getName());
        try {
            ModuleDecl module = findModule();
            for (Decl decl : module.getDecls()) {
                if (decl instanceof ClassDecl && decl.getName().equals(this.getSimpleName()))
                    return (ClassDecl) decl;
            }
            // not found
            throw new DeltaModellingException(getDelta(), 
                    " wants to modify class [" + this.getSimpleName() + "], which was not found in module [" + module.getName() + "].");
        } catch (DeltaModellingException e) { return null; }
    }

    public InterfaceDecl InterfaceModifier.findInterface() throws DeltaModellingException {
        //System.out.println("=== Delta " + getDelta().getName() + " looking for InterfaceDecl: " + this.getName());

        ModuleDecl module = findModule();
        for (Decl decl : module.getDecls()) {
            if (decl instanceof InterfaceDecl && decl.getName().equals(this.getSimpleName()))
                return (InterfaceDecl) decl;
        }
        // not found
        throw new DeltaModellingException(getDelta(), 
                " wants to modify interface [" + this.getSimpleName() + "], which was not found in module [" + module.getName() + "].");
    }

    
    /**************************************************************************
     * Modifiers are applied to Classes
     * - add/remove/modify methods
     * - add/remove fields
     */
    public abstract void Modifier.applyTo(ClassDecl cd) throws DeltaModellingException;



    public void RemoveFieldModifier.applyTo(ClassDecl cd) throws DeltaModellingException {
        FieldDecl myfield = getFieldDecl();

        // in given ClassDecl: find FieldDecl that matches this
        int found = -1;
        for (int i = 0; i < cd.getNumField(); i++) {
            FieldDecl field = cd.getField(i);
            if (field.matches(myfield)) {
                found = i;
                break;
            }
        }
        if (found >= 0)
            cd.getFields().removeChild(found);
        else
            throw new DeltaModellingWithNodeException(getFieldDecl(), getDelta(), 
                    " wants to remove field [" + myfield + "], which was not found in class [" + cd.qualifiedName() + "].");
    }

    public void AddFieldModifier.applyTo(ClassDecl cd) {
        FieldDecl field = getFieldDecl().treeCopyNoTransform();
        field.setFileName(getFieldDecl().getFileName());
        cd.addField(field);
    }
    
    /**************************************************************************
     * MethodSigModifiers are applied to Interfaces
     * - add/remove method signatures
     */
    public abstract void MethodSigModifier.applyTo(InterfaceDecl iface) throws DeltaModellingException;

    public void AddMethodSigModifier.applyTo(InterfaceDecl iface) throws DeltaModellingException {
        MethodSig sig = getMethodSig().treeCopyNoTransform();
        sig.setFileName(getMethodSig().getFileName());
        iface.addBody(sig);
    }
    public void RemoveMethodSigModifier.applyTo(InterfaceDecl iface) throws DeltaModellingException {
        MethodSig mysig = this.getMethodSig();

        // in given InterfaceDecl: find MethodSig that matches mysig
        int found = -1;
        for (int i = 0; i < iface.getNumBody(); i++) {
            MethodSig sig = iface.getBody(i);
            if (sig.matches(mysig)) {
                found = i;
                break;
            }
        }
        if (found >= 0)
            // remove MethodSig
            iface.getBodys().removeChild(found);
        else
            throw new DeltaModellingException(getDelta(), 
                    " wants to remove method signature [" + mysig + "], which was not found in interface [" + iface.qualifiedName() + "].");
    }
    
    //traits
    public  void DeltaTraitModifier.applyTo(ClassDecl cd) throws DeltaModellingException{ getTraitOper().applyTo(cd); }
  public void TraitAddOpr.applyTo(ClassDecl cd) throws DeltaModellingException{ 
		  TraitExpr tt = getTraitExpr();
		  ArrayList<TraitOper> operations = new ArrayList<>();
		  TraitExpr target = helperLeftMost(tt, operations);
		  
		  Collections.reverse(operations);
                  applySimple(cd,target);
                  for (TraitOper oper : operations) {
                    oper.applyTo(cd);
                  }
    }
  
  public TraitExpr TraitAddOpr.helperLeftMost(TraitExpr tt, ArrayList<TraitOper> operations){
      if(tt instanceof TraitModifyExpr){          
          TraitModifyExpr app = (TraitModifyExpr) tt;
          TraitExpr next = app.getTraitExpr();
          TraitOper opr = app.getTraitOper();
          operations.add(opr);
          return helperLeftMost(next, operations);
      } else return tt;
  }
  
  private void TraitAddOpr.applySimple(ClassDecl cd, TraitExpr tt)  throws DeltaModellingException{
      if(tt instanceof TraitSetExpr ){
          TraitSetExpr set = (TraitSetExpr) tt;
          for (MethodImpl met : set.getMethodImplList()) {
              MethodImpl method = met.treeCopyNoTransform();
              method.setFileName(met.getFileName());
              cd.addMethod(method);
        }
      } else if(tt instanceof TraitNameExpr){
          TraitNameExpr name = (TraitNameExpr) tt;
          TraitUse use = new TraitUse(name.treeCopyNoTransform());
          use.applyTo(cd);
          //cd.addTraitUse(new TraitUse(name));
      }else  throw new DeltaModellingException("trait error");
  }
    
    
 public void TraitModifyOpr.applyTo(ClassDecl cd) throws DeltaModellingException{ 
      TraitExpr tt = getTraitExpr();
      ArrayList<TraitOper> operations = new ArrayList<>();
      TraitExpr target = helperLeftMost(tt, operations);
      applySimple(cd,target);
      for (TraitOper oper : operations) {
        oper.applyTo(cd);
      }
}

public TraitExpr TraitModifyOpr.helperLeftMost(TraitExpr tt, ArrayList<TraitOper> operations){
    if(tt instanceof TraitModifyExpr){          
        TraitModifyExpr app = (TraitModifyExpr) tt;
        TraitExpr next = app.getTraitExpr();
        TraitOper opr = app.getTraitOper();
        operations.add(opr);
        return helperLeftMost(next, operations);
    } else return tt;
}
  
  private void TraitModifyOpr.apply(ClassDecl cd, MethodImpl met) throws DeltaModellingException{
      MethodSig mysig = met.getMethodSig();

      // in given ClassDecl: find MethodDecl that matches sig
      int found = -1;
      for (int i = 0; i < cd.getNumMethod(); i++) {
          MethodSig sig = cd.getMethod(i).getMethodSig();
          if (sig.matches(mysig)) {
              found = i;
              break;
          }
      }
      if (found >= 0) {
          // replace MethodImpl
          MethodImpl method = met.treeCopyNoTransform();
          method.setFileName(met.getFileName());
          method.setParent(met.getParent());
          replaceOriginal(cd, cd.getMethod(found), method);
          cd.getMethods().setChild(method, found);
      } else
          throw new DeltaModellingWithNodeException(met.getMethodSig(), getDelta(), 
                  " wants to modify method [" + mysig + "], which was not found in class [" + cd.qualifiedName() + "].");
  }
  
  private void TraitModifyOpr.replaceOriginal(ClassDecl cd, MethodImpl met, MethodImpl flattened) {
            
      ASTNode<ASTNode> n = this;
      while(n != null && !(n instanceof DeltaDecl)){
          n = n.getParent();
      }
      DeltaDecl delta  = (DeltaDecl)n;
      if(delta != null){
          String mName = met.getMethodSig().getName();
          HashMap<String, MethodImpl> map = deltaMap.get(mName);
          if(map == null){
              map = new HashMap<>();
              map.put("core", flattened);
              deltas.push("core");
              deltaMap.put(mName, map);
          }
      }
      
      ArrayList<OriginalCall> list = new ArrayList<>();
      for (Stmt stmt : flattened.getBlock().getStmts()){
          collectOrig(list, stmt);
      }
      if(list.size() > 0){
          int i = cd.getNumMethod();
          String name = met.getMethodSig().getName() + (delta == null? hashCode() : "_"+delta.getName())/*+ "_"+hashCode()*/;
          MethodSig sig = met.getMethodSig().treeCopyNoTransform();
          sig.setName(name);
          MethodImpl newMet = met.treeCopyNoTransform();
          newMet.setParent(met.getParent());
          newMet.setMethodSig(sig);

          sig.setParent(newMet);
          cd.getMethods().setChild(newMet, i);

          if(delta != null){
              String mName = met.getMethodSig().getName();
              HashMap<String, MethodImpl> map = deltaMap.get(mName);
              map.put(/*delta.getName()*/deltas.peek(), newMet);
              map.put(delta.getName(), flattened);
              deltas.push(delta.getName());
          }
          
          for (OriginalCall orig : list) {
            orig.replaceByRealCall(newMet, deltaMap.get(met.getMethodSig().getName()));
          }
      }
          
  }
  
  private static Stack<String> TraitModifyOpr.deltas = new Stack<>();
  
  private static HashMap<String, HashMap<String, MethodImpl>> TraitModifyOpr.deltaMap = new HashMap<>();
          
  
  
  private void TraitModifyOpr.collectOrig(ArrayList<OriginalCall> list, ASTNode<ASTNode> node){
      if(node instanceof OriginalCall){
          list.add((OriginalCall)node);
          return;
      }
      if(node != null && node.children != null)
	      for (ASTNode<ASTNode> child : node.children) {
	          collectOrig(list,child);
	      }
  }

  private void TraitModifyOpr.applySimple(ClassDecl cd, TraitExpr tt)  throws DeltaModellingException{
      if(tt instanceof TraitSetExpr ){
          TraitSetExpr set = (TraitSetExpr) tt;
          for (MethodImpl met : set.getMethodImplList()) {
              apply(cd,met);
          }
      } else if(tt instanceof TraitNameExpr){
          //throw new DeltaModellingException("trait error: not implemened yet");
          TraitNameExpr n = (TraitNameExpr) tt;

          List<Decl> list = cd.getModuleDecl().getDecls();
          TraitExpr resolved = null;
              for (Decl decl : list) {
                if(decl instanceof TraitDecl){
                    TraitDecl tDecl = (TraitDecl)decl;
                    if( tDecl.getName().equals(n.getName()) ){
                        resolved = tDecl.getTraitExpr();
                        break;
                    }
                }
          
        } 
          if(resolved == null)throw new DeltaModellingException("trait error: trait not found");
          TraitModifyOpr op = new TraitModifyOpr(resolved.treeCopyNoTransform());
          op.setParent(cd);
          op.applyTo(cd);
          /*
          TraitNameExpr actName = new TraitNameExpr(name.getName() + "_" + hashCode());
          TraitDecl decl = new TraitDecl(actName.getName(), 
                             new TraitModifyExpr(new TraitSetExpr(new List<MethodImpl>()), new TraitModifyOpr(tt.treeCopyNoTransform())));
          cd.getModuleDecl().addDecl(decl);//should also apply, see test.abs
          TraitUse use = new TraitUse(actName);
          //cd.addTraitUse(new TraitUse(actName));
          use.applyTo(cd);*/
      }else  throw new DeltaModellingException("trait error");
  }
    		
    public  void TraitRemoveOpr.applyTo(ClassDecl cd) throws DeltaModellingException{ 

  	        MethodSig mysig = this.getMethodSig();

  	        // in given ClassDecl: find MethodDecl that matches sig
  	        int found = -1;
  	        for (int i = 0; i < cd.getNumMethod(); i++) {
  	            MethodSig sig = cd.getMethod(i).getMethodSig();
  	            if (sig.matches(mysig)) {
  	                found = i;
  	                break;
  	            }
  	        }
  	        if (found >= 0)
  	            // remove MethodImpl from list
  	            cd.getMethods().removeChild(found);
  	        else
  	            throw new DeltaModellingException(getDelta(), 
  	                    " wants to remove method [" + mysig + "], which was not found in class [" + cd.qualifiedName() + "].");
  	}
  	
  	 public  void TraitUse.applyTo(ClassDecl cd) throws DeltaModellingException {

      List<Decl> list = cd.getModuleDecl().getDecls();
      TraitExpr resolved = getTraitExpr();
      if(getTraitExpr() instanceof TraitNameExpr){
          TraitNameExpr n = (TraitNameExpr) getTraitExpr();
          for (Decl decl : list) {
            if(decl instanceof TraitDecl){
                TraitDecl tDecl = (TraitDecl)decl;
                if( tDecl.getName().equals(n.getName()) ){
                    resolved = tDecl.getTraitExpr();
                    break;
                }
            }
      }
    } 
      resolved = resolved.treeCopyNoTransform();
      TraitAddOpr tOp = new TraitAddOpr(resolved);
      resolved.setParent(tOp);
      tOp.setParent(cd);
      tOp.applyTo(cd);
      int pos = cd.getTraitUseList().getIndexOfChild(this);
      if(pos > -1){
          cd.getTraitUseList().removeChild(pos);
      }
      cd.getModuleDecl().flushCache();
  }
}
