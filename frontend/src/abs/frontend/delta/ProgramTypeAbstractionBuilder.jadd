import com.google.common.collect.ImmutableList;

aspect ProgramTypeAbstractionBuilder {

    /*******************************************************************************************************
     *
     * Build type abstraction of the core program
     */
    public void Model.buildCoreTypeAbstraction(ProgramTypeAbstraction ta) {
        for (Decl decl : getDecls()) {
            if (decl.isClass()) {
                String className = decl.qualifiedName();
                ta.classAdd(className);
                for (FieldDecl field : ((ClassDecl) decl).getFields())
                    ta.classFieldAdd(className, field.getName(), field.getType().toString());
                for (MethodImpl method : ((ClassDecl) decl).getMethods()) {
                    java.util.List<String> types = CompilerUtils.getMethodParameterTypes(method.getMethodSig());
                    ta.classMethodAdd(className, method.getMethodSig().getName(), types);
                }
            } else if (decl.isInterface()) {
                String ifName = decl.qualifiedName();
                ta.interfaceAdd(ifName);
                for (MethodSig sig : ((InterfaceDecl) decl).getBodys()) {
                    java.util.List<String> types = CompilerUtils.getMethodParameterTypes(sig);
                    ta.interfaceMethodAdd(ifName, sig.getName(), types);
                }
            }

            // TODO: record other elements (functions etc.) ?
        }
    }


    abstract public void ModuleModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta);
    abstract public void Modifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className);

    /*******************************************************************************************************
     *
     * Class Modifiers
     */
    public void AddClassModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classAdd(this);
        String className = getClassDecl().qualifiedName();
        for (FieldDecl field : getClassDecl().getFields())
            ta.classFieldAdd(className, field.getName(),  field.getType().toString());
        for (MethodImpl method : getClassDecl().getMethods()) {
            java.util.List<String> types = CompilerUtils.getMethodParameterTypes(method.getMethodSig());
            ta.classMethodAdd(className, method.getMethodSig().getName(), types);
        }
    }

    public void ModifyClassModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        String className = qualifiedName();
        if (ta.existsClass(this)) {
            for (InterfaceTypeUse iface : getAddedInterfaces())
                ta.classInterfaceAdd(className, iface);
            for (InterfaceTypeUse iface : getRemovedInterfaces())
                ta.classInterfaceRemove(className, iface);
            for (Modifier mod : getModifiers())
                mod.applyToTypeAbstraction(ta, className);
        }
    }

    public void RemoveClassModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classRemove(this);
    }


    /*
     * Interface Modifiers
     */
    public void AddInterfaceModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        // TODO
    }
    public void ModifyInterfaceModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        // TODO
    }
    public void RemoveInterfaceModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        // TODO
    }

    /*
     * Export/Import Modifiers
     */
    public void AddExportModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }
    public void AddImportModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }

    /*
     * Functional Modifiers
     */
    public void AddDataTypeModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }
    public void ModifyDataTypeModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }
    public void AddFunctionModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }
    public void AddTypeSynModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }
    public void ModifyTypeSynModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta) {
        // TODO
    }


    /*******************************************************************************************************
     *
     * Modifiers are applied to classes
     */
    public void AddFieldModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classFieldAdd(className, this);
    }
    public void RemoveFieldModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classFieldRemove(className, this);
    }


    /************************************
     *
     *		Modifiers shared between deltas and traits
     */

    // Eduard will make this obsolete
    public void TraitUse.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        // TODO
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
    }

    public void DeltaTraitModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        getMethodModifier().applyToTypeAbstraction(ta, className);
    }

    public void AddMethodModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classMethodAdd(className, this);
    }
    public void ModifyMethodModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classMethodModify(className, this);
    }
    public void RemoveMethodModifier.applyToTypeAbstraction(ProgramTypeAbstraction ta, String className) {
        if (getModel().debug)
            System.out.println("___ applyToTypeAbstraction " + getClass().getName());
        ta.classMethodRemove(className, this);
    }

}